#!/usr/bin/env node
// Minimal ESM launcher for the compiled MCP server with a help handler.

import pkg from '../package.json' with { type: 'json' };

const args = process.argv.slice(2);
const wantsHelp = args.includes('-h') || args.includes('--help') || args.includes('help');
const wantsVersion = args.includes('-v') || args.includes('--version') || args.includes('version');
const wantsPreflightOnly = args.includes('--preflight-only');

const version = (pkg && pkg.version) || process.env.npm_package_version || 'unknown';

if (wantsHelp) {
  const usage = `
scan-mcp v${version}

Usage:
  scan-mcp [--help] [--version] [--preflight-only]

Description:
  Minimal MCP server for scanner capture (ADF/duplex/page-size), batching, and multipage assembly.

Options:
  --help            Show this help message
  --version         Show version number
  --preflight-only  Run preflight checks only and exit

Environment:
  SCAN_MOCK                Mock SANE; generate fake TIFFs (default: false)
  INBOX_DIR                Base directory for job runs (default: scanned_documents/inbox)
  SCANIMAGE_BIN            Path to scanimage (default: scanimage)
  SCANADF_BIN              Path to scanadf (default: scanadf)
  TIFFCP_BIN               Path to tiffcp (default: tiffcp)
  IM_CONVERT_BIN           Path to convert (default: convert)
  SCAN_EXCLUDE_BACKENDS    CSV backends to exclude (e.g., v4l)
  SCAN_PREFER_BACKENDS     CSV backends to prefer (e.g., epjitsu,epson2)
  PERSIST_LAST_USED_DEVICE Persist and prefer last used device (default: true)

Examples:
  # Run directly
  scan-mcp

  # Via npx in MCP client config
  {
    "mcpServers": {
      "scan": { "command": "npx", "args": ["scan-mcp"] }
    }
  }
`;
  console.log(usage.trim());
  process.exit(0);
}

if (wantsVersion) {
  console.log(version);
  process.exit(0);
}

if (wantsPreflightOnly) {
  (async () => {
    try {
      const preflight = await import('../dist/preflight.js');
      if (typeof preflight.ensureEnvironmentReady === 'function') {
        await preflight.ensureEnvironmentReady({ verbose: true });
        process.exit(0);
      } else {
        console.error('Preflight module not available');
        process.exit(1);
      }
    } catch (error) {
      const preflight = await import('../dist/preflight.js');
      if (preflight.PreflightError && error instanceof preflight.PreflightError) {
        console.error(error.message);
        process.exit(1);
      }
      console.error(error);
      process.exit(1);
    }
  })().catch((err) => {
    console.error(err);
    process.exit(1);
  });
  // The IIFE above will handle the exit, preventing bootstrap from running
} else {
  async function bootstrap() {
    try {
      const preflight = await import('../dist/preflight.js');
      if (typeof preflight.ensureEnvironmentReady === 'function') {
        try {
          await preflight.ensureEnvironmentReady();
        } catch (error) {
          if (preflight.PreflightError && error instanceof preflight.PreflightError) {
            console.error(error.message);
            process.exit(1);
            return;
          }
          throw error;
        }
      }
    } catch (error) {
      console.error(error);
      process.exit(1);
      return;
    }

    try {
      const mod = await import('../dist/mcp.js');
      if (typeof mod.main !== 'function') {
        console.error('scan-mcp entrypoint missing main() export');
        process.exit(1);
        return;
      }
      await mod.main();
    } catch (error) {
      console.error(error);
      process.exit(1);
    }
  }

  bootstrap().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
